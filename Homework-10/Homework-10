// APIExplorer.swift
// iOS 16+ / Swift 5.7+
// Single-file prototype for "API Explorer" (Rick & Morty)
// Features: fetch characters, paging, search (server-side), pull-to-refresh, detail, favorites (UserDefaults), simple image caching via URLCache, clean MVVM, mockable network layer + sample unit tests.

import SwiftUI
import Combine

// MARK: - Models (match Rick & Morty API)
struct RMInfo: Codable {
    let count: Int
    let pages: Int
    let next: String?
    let prev: String?
}

struct RMCharacterListResponse: Codable {
    let info: RMInfo
    let results: [RMCharacter]
}

struct RMCharacter: Codable, Identifiable, Hashable {
    let id: Int
    let name: String
    let status: String?
    let species: String?
    let type: String?
    let gender: String?
    let origin: RMOrigin?
    let location: RMLocation?
    let image: String?
    let episode: [String]?
    let url: String?
    let created: String?
}

struct RMOrigin: Codable, Hashable {
    let name: String?
    let url: String?
}

struct RMLocation: Codable, Hashable {
    let name: String?
    let url: String?
}

// MARK: - Network Layer (protocol + implementation)
enum NetworkError: Error, LocalizedError {
    case badURL, requestFailed(Error), invalidResponse, decodingError(Error), statusCode(Int)
    var errorDescription: String? {
        switch self {
        case .badURL: return "Geçersiz URL"
        case .requestFailed(let e): return "İstek hatası: \(e.localizedDescription)"
        case .invalidResponse: return "Geçersiz cevap"
        case .decodingError(let e): return "Decode hatası: \(e.localizedDescription)"
        case .statusCode(let code): return "Sunucu hatası: \(code)"
        }
    }
}

protocol NetworkServiceProtocol {
    func fetchCharacters(page: Int, name: String?) async throws -> RMCharacterListResponse
    func fetchData(from url: URL) async throws -> Data
}

final class NetworkService: NetworkServiceProtocol {
    private let base = "https://rickandmortyapi.com/api/character"
    private let session: URLSession
    
    init(session: URLSession = .shared) {
        self.session = session
    }
    
    func fetchCharacters(page: Int, name: String? = nil) async throws -> RMCharacterListResponse {
        var components = URLComponents(string: base)
        var queryItems: [URLQueryItem] = [URLQueryItem(name: "page", value: "\(page)")]
        if let q = name, !q.trimmingCharacters(in: .whitespaces).isEmpty {
            queryItems.append(URLQueryItem(name: "name", value: q))
        }
        components?.queryItems = queryItems
        guard let url = components?.url else { throw NetworkError.badURL }
        
        let (data, response): (Data, URLResponse)
        do {
            (data, response) = try await session.data(from: url)
        } catch {
            throw NetworkError.requestFailed(error)
        }
        guard let http = response as? HTTPURLResponse else { throw NetworkError.invalidResponse }
        guard (200...299).contains(http.statusCode) else { throw NetworkError.statusCode(http.statusCode) }
        
        do {
            return try JSONDecoder().decode(RMCharacterListResponse.self, from: data)
        } catch {
            throw NetworkError.decodingError(error)
        }
    }
    
    func fetchData(from url: URL) async throws -> Data {
        do {
            let (data, response) = try await session.data(from: url)
            guard let http = response as? HTTPURLResponse, (200...299).contains(http.statusCode) else {
                throw NetworkError.invalidResponse
            }
            return data
        } catch {
            throw NetworkError.requestFailed(error)
        }
    }
}

// MARK: - Image Loader (simple URLCache-backed)
final class ImageLoader: ObservableObject {
    @Published var image: UIImage?
    private var task: Task<Void, Never>?
    private static let cache = URLCache(memoryCapacity: 50 * 1024 * 1024, diskCapacity: 200 * 1024 * 1024)
    
    func loadImage(from urlString: String?) {
        task?.cancel()
        image = nil
        guard let s = urlString, let url = URL(string: s) else { return }
        
        task = Task { @MainActor in
            let request = URLRequest(url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: 30)
            if let cached = ImageLoader.cache.cachedResponse(for: request), let ui = UIImage(data: cached.data) {
                self.image = ui
                return
            }
            do {
                let (data, response) = try await URLSession.shared.data(for: request)
                if let response = response as? HTTPURLResponse, (200...299).contains(response.statusCode) {
                    ImageLoader.cache.storeCachedResponse(CachedURLResponse(response: response, data: data), for: request)
                    if let ui = UIImage(data: data) {
                        self.image = ui
                    }
                }
            } catch {
                // ignore — image remains nil
            }
        }
    }
    
    func cancel() {
        task?.cancel()
    }
}

// MARK: - Favorites Persistence (UserDefaults)
final class FavoritesStore: ObservableObject {
    @Published private(set) var favorites: Set<Int> = []
    private let key = "favorites.characters.v1"
    static let shared = FavoritesStore()
    
    private init() {
        load()
    }
    
    private func load() {
        if let data = UserDefaults.standard.data(forKey: key),
           let arr = try? JSONDecoder().decode([Int].self, from: data) {
            self.favorites = Set(arr)
        } else {
            self.favorites = []
        }
    }
    
    private func save() {
        let arr = Array(favorites)
        if let data = try? JSONEncoder().encode(arr) {
            UserDefaults.standard.set(data, forKey: key)
        }
    }
    
    func toggle(_ id: Int) {
        if favorites.contains(id) { favorites.remove(id) } else { favorites.insert(id) }
        save()
    }
    
    func contains(_ id: Int) -> Bool {
        favorites.contains(id)
    }
}

// MARK: - ViewModels
@MainActor
final class CharacterListViewModel: ObservableObject {
    @Published private(set) var characters: [RMCharacter] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var pageInfo: RMInfo? = nil
    @Published var searchText: String = ""
    
    private var page = 1
    private var service: NetworkServiceProtocol
    private var isFetching = false
    
    init(service: NetworkServiceProtocol = NetworkService()) {
        self.service = service
    }
    
    func resetAndFetch() async {
        page = 1
        pageInfo = nil
        characters = []
        await fetchNextIfNeeded()
    }
    
    func fetchNextIfNeeded() async {
        guard !isFetching else { return }
        if let info = pageInfo, page > info.pages { return } // no more
        isFetching = true
        isLoading = true
        errorMessage = nil
        
        do {
            let resp = try await service.fetchCharacters(page: page, name: searchText.isEmpty ? nil : searchText)
            if page == 1 {
                characters = resp.results
            } else {
                characters += resp.results
            }
            pageInfo = resp.info
            page += 1
        } catch {
            if let ne = error as? NetworkError {
                errorMessage = ne.localizedDescription
            } else {
                errorMessage = error.localizedDescription
            }
        }
        
        isLoading = false
        isFetching = false
    }
    
    /// Call when user pulls to refresh or updates search
    func refresh() async {
        page = 1
        characters = []
        pageInfo = nil
        await fetchNextIfNeeded()
    }
}

@MainActor
final class CharacterDetailViewModel: ObservableObject {
    @Published var character: RMCharacter
    @Published var isFavorite: Bool = false
    private var favStore: FavoritesStore
    
    init(character: RMCharacter, favStore: FavoritesStore = .shared) {
        self.character = character
        self.favStore = favStore
        self.isFavorite = favStore.contains(character.id)
    }
    
    func toggleFavorite() {
        favStore.toggle(character.id)
        isFavorite = favStore.contains(character.id)
    }
}

// MARK: - Views

struct ContentView: View {
    var body: some View {
        TabView {
            NavigationStack {
                CharacterListView()
            }
            .tabItem {
                Label("Characters", systemImage: "person.3.fill")
            }
            FavoritesView()
                .tabItem {
                    Label("Favorites", systemImage: "star.fill")
                }
        }
    }
}

// Character Row
struct CharacterRowView: View {
    let character: RMCharacter
    @StateObject private var loader = ImageLoader()
    @EnvironmentObject var favStore: FavoritesStore
    
    var body: some View {
        HStack(spacing: 12) {
            ZStack {
                Rectangle().fill(.gray.opacity(0.2)).cornerRadius(8)
                if let ui = loader.image {
                    Image(uiImage: ui)
                        .resizable()
                        .scaledToFill()
                        .frame(width: 72, height: 72)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                } else {
                    ProgressView()
                        .frame(width: 72, height: 72)
                }
            }
            .frame(width: 72, height: 72)
            VStack(alignment: .leading, spacing: 4) {
                Text(character.name)
                    .font(.headline)
                HStack(spacing: 8) {
                    if let species = character.species { Text(species).font(.caption) }
                    if let status = character.status { Text(status).font(.caption).foregroundColor(.secondary) }
                }
                .foregroundColor(.secondary)
            }
            Spacer()
            if favStore.contains(character.id) {
                Image(systemName: "star.fill").foregroundColor(.yellow)
            }
        }
        .onAppear {
            loader.loadImage(from: character.image)
        }
        .onDisappear {
            loader.cancel()
        }
    }
}

// List view with paging, search, pull-to-refresh
struct CharacterListView: View {
    @StateObject private var vm = CharacterListViewModel()
    @StateObject private var favStore = FavoritesStore.shared
    @State private var isSearching = false
    
    var body: some View {
        VStack {
            if #available(iOS 16.0, *) {
                List {
                    Section {
                        // Search field
                        HStack {
                            TextField("Search by name...", text: $vm.searchText, prompt: Text("Ex: Rick"))
                                .textFieldStyle(.roundedBorder)
                                .onSubmit {
                                    Task { await vm.resetAndFetch() }
                                }
                            Button("Ara") {
                                Task { await vm.resetAndFetch() }
                            }
                        }
                    }
                    Section {
                        ForEach(vm.characters) { char in
                            NavigationLink(value: char) {
                                CharacterRowView(character: char)
                                    .environmentObject(favStore)
                                    .padding(.vertical, 6)
                                    .onAppear {
                                        Task {
                                            // trigger fetch next when near end
                                            if vm.characters.isLastItem(char) {
                                                await vm.fetchNextIfNeeded()
                                            }
                                        }
                                    }
                            }
                        }
                        if vm.isLoading {
                            HStack {
                                Spacer()
                                ProgressView()
                                Spacer()
                            }
                        } else if vm.pageInfo?.next != nil {
                            HStack {
                                Spacer()
                                Button("Daha Fazla Yükle") {
                                    Task { await vm.fetchNextIfNeeded() }
                                }
                                Spacer()
                            }
                        }
                    }
                }
                .listStyle(.insetGrouped)
                .navigationTitle("Rick & Morty")
                .navigationDestination(for: RMCharacter.self) { character in
                    CharacterDetailView(viewModel: CharacterDetailViewModel(character: character))
                }
                .refreshable {
                    await vm.refresh()
                }
                .overlay {
                    if let err = vm.errorMessage {
                        VStack {
                            Text("Hata: \(err)").foregroundColor(.red).multilineTextAlignment(.center)
                            Button("Yeniden Dene") {
                                Task { await vm.resetAndFetch() }
                            }
                        }
                        .padding()
                        .background(.ultraThinMaterial)
                        .cornerRadius(12)
                        .padding()
                    }
                }
                .task {
                    await vm.fetchNextIfNeeded()
                }
                .environmentObject(favStore)
            } else {
                // fallback for earlier iOS versions (simplified)
                Text("iOS 16 veya üzeri önerilir.")
            }
        }
    }
}

// Detail view
struct CharacterDetailView: View {
    @StateObject var viewModel: CharacterDetailViewModel
    @StateObject private var loader = ImageLoader()
    
    init(viewModel: CharacterDetailViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel)
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 16) {
                if let url = viewModel.character.image {
                    ZStack {
                        Rectangle().fill(.gray.opacity(0.1)).cornerRadius(12)
                        if let ui = loader.image {
                            Image(uiImage: ui)
                                .resizable()
                                .scaledToFit()
                                .cornerRadius(12)
                                .frame(maxWidth: .infinity)
                        } else {
                            ProgressView().frame(height: 240)
                        }
                    }
                    .onAppear { loader.loadImage(from: url) }
                    .onDisappear { loader.cancel() }
                    .padding(.horizontal)
                }
                VStack(alignment: .leading, spacing: 8) {
                    Text(viewModel.character.name).font(.largeTitle).bold()
                    HStack {
                        if let status = viewModel.character.status {
                            Label(status, systemImage: "heart.fill")
                        }
                        Spacer()
                        if let species = viewModel.character.species {
                            Text(species)
                        }
                    }
                    .foregroundColor(.secondary)
                    
                    Divider()
                    
                    Group {
                        if let origin = viewModel.character.origin?.name {
                            Text("Origin: \(origin)")
                        }
                        if let loc = viewModel.character.location?.name {
                            Text("Location: \(loc)")
                        }
                        if let gender = viewModel.character.gender {
                            Text("Gender: \(gender)")
                        }
                    }
                    .font(.body)
                }
                .padding(.horizontal)
                
                Button(action: {
                    viewModel.toggleFavorite()
                }, label: {
                    HStack {
                        Image(systemName: viewModel.isFavorite ? "star.fill" : "star")
                        Text(viewModel.isFavorite ? "Favorilerden Kaldır" : "Favorilere Ekle")
                    }
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(.blue)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                    .padding(.horizontal)
                })
            }
            .padding(.vertical)
        }
        .navigationTitle(viewModel.character.name)
        .navigationBarTitleDisplayMode(.inline)
    }
}

// Favorites tab
struct FavoritesView: View {
    @StateObject private var favStore = FavoritesStore.shared
    @StateObject private var vm = CharacterListViewModel()
    
    var body: some View {
        NavigationStack {
            VStack {
                if favStore.favorites.isEmpty {
                    VStack {
                        Text("Henüz favori yok").foregroundColor(.secondary)
                        Text("Listeden bir karakteri favorilere ekleyin.")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                } else {
                    List {
                        ForEach(Array(favStore.favorites), id: \.self) { id in
                            // For simplicity: fetch details one-by-one (could be optimized)
                            FavoriteRowView(characterId: id)
                        }
                        .onDelete { idx in
                            let ids = Array(favStore.favorites)
                            idx.forEach { i in
                                let id = ids[i]
                                favStore.toggle(id)
                            }
                        }
                    }
                    .listStyle(.insetGrouped)
                }
            }
            .navigationTitle("Favoriler")
        }
    }
}

struct FavoriteRowView: View {
    let characterId: Int
    @State private var character: RMCharacter?
    @StateObject private var loader = ImageLoader()
    private let service: NetworkServiceProtocol = NetworkService()
    
    var body: some View {
        HStack {
            if let char = character {
                if let ui = loader.image {
                    Image(uiImage: ui)
                        .resizable()
                        .frame(width: 64, height: 64)
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                } else {
                    Rectangle().fill(.gray.opacity(0.2)).frame(width: 64, height: 64)
                }
                VStack(alignment: .leading) {
                    Text(char.name).bold()
                    Text(char.species ?? "").font(.caption).foregroundColor(.secondary)
                }
            } else {
                ProgressView()
            }
        }
        .onAppear {
            Task {
                await loadCharacter()
            }
        }
    }
    
    func loadCharacter() async {
        guard let url = URL(string: "https://rickandmortyapi.com/api/character/\(characterId)") else { return }
        do {
            let data = try await service.fetchData(from: url)
            let decoded = try JSONDecoder().decode(RMCharacter.self, from: data)
            await MainActor.run {
                self.character = decoded
                loader.loadImage(from: decoded.image)
            }
        } catch {
            // ignore for now
        }
    }
}

// MARK: - Helpers
extension RandomAccessCollection where Element: Identifiable {
    func isLastItem(_ item: Element) -> Bool {
        guard !isEmpty else { return false }
        guard let itemIndex = firstIndex(where: { $0.id == item.id }) else { return false }
        let distance = self.distance(from: itemIndex, to: endIndex)
        return distance <= 2 // when 2 items left -> load more
    }
}

// MARK: - App Entry
@main
struct APIExplorerApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
